#encoding=utf-8

import copy
# '==' VS 'is'
# '==' 操作符，比较对象之间的值是否相等
a = 10
b = 10

a == b
True
# 'is' 操作符比较的是对象的身份标识是否相等：是否是同一个对象，是否指向同一个内存地址
# 每个对象的身份标识，都能通过函数id(object)获得。因此，‘is'操作符，相当于比较对象之间的ID是否相等

id(a)   # 4427562448
id(b)   # 4427562448

a is b
True

# 原理：首先Python为「10」这个值开辟一块内存，变量a和变量b都是指向这块内存区域
#       即a、b都是指向10这个变量，所以a、b的值相等，id也相等。
#       注：a is b 为True，只适用于-5到256范围内的数字，
c = 257
d = 257
c == d # True      因为a、b指向的值相同
c is d # False     因为id不一样，因为：Python内部对-5到256的整形维持一个数组，
       #            起到缓存的作用，若超过了这个范围，则会为257开辟两块内存区域，因此id不同
a is None

t1 = (1,2,[3,4])
t2 = (1,2,[3,4])
t1 == t2
True

t1[-1].append(5)
t1 == t2
False   # 元组是不可变得，但元组可以嵌套列表类型（列表是可变元素）

# shallow copy 和 deep copy
# 浅拷贝方法：1. 数据类型本身的构造器
#           2. 通过切片操作符「:」(除tuple)
l1 = [1,2,3]
l2 = list(l1)

l2  # [1,2,3]
l1 == l2    # True
l1 is l2    # False

s1 = set([1,2,3])
s2 = set(s1)

s2      # {1,2,3}
s1 == s2    # True
s1 is s2    # False
s3 = copy.copy(s1)
s1 == s3    # True
s1 is s3    # False

l1 = [1,2,3]
l2 = l1[:]
l1 == l2    # True
l1 is l2    # Fasle

t1 = (1,2,3)
t2 = tuple(t1)
t3 = t1[:]  # tuple 或 ：，不会创建一份浅拷贝，而是返回一个指向相同的元组的引用
t1 == t2 == t3    # True
t1 is t2    # True 元组只被创建了一次，t1和t2同时指向了这个元组
t1 is t3   

# 浅拷贝原理：1、重新分配一块内存，**创建一个新的对象**，里面的元素是原对象的引用，指向同一个对象。
#           2、如果原对象的元素可变，浅拷贝会有一些副作用
l1 = [[1,2], (30,40)]
l2 = list(l1)
l2  # [[1,2],(30,40)]
l1.append(100)  # l2不变，是因为l2和l1作为整体是两个不同的对象，并不共享内存地址。？
l1[0].append(3) # l2改变，是因为l2中的第一个元素和l1中的第一个元素，共同指向一个列表。？
l1  # [[1,2,3],(30,40),100]
l2  # [[1,2,3],(30,40)]
l1[1] += (50,60)    # l2不变，因为元组不可变，l1中的第二个元素是元组的拼接，是指创建了一个新的元组
l1  # [[1,2,3],(30,40,50,60)]
l2  # [[1,2,3],(30,40)]


# 深拷贝原理：1、重新分配一块内存，创建一个新的对象，将原对象中的元素以递归的方式，通过创建新的子对象拷贝到新对象中。
#           2、新对象和原对象没有任何关联
l1 = [[1,2], (30,40)]
l2 = copy.deepcopy(l1)
l1.append(100)
l1[0].append(3)
l1  # [[1,2,3], (30,40), 100]
l2  # [[1,2], (30,40)]

l3 = [1,2,3]
l4 = copy.deepcopy(l3)
l3 == l4    # True
l3 is l4    # False


# summary
# 浅拷贝：不可变得不可变，可变的依旧可变；深拷贝：都不可变。



## 变量及赋值
a = 1
b = a
a = a + 1
# 1、这里先将1赋值于a，即a指向了1这个对象
# 2、接着b=a，表示，让变量b也同时指向了1这个对象。
# 3、最后执行a = a+1，并不是让a的值加1，而是**重新创建了一个新的值为2的对象**，并让a指向它，因为int和字符串类型是不可变得。
# 所有a的值变成了2，而b的值不变

l1 = [1,2,3]
l2 = l1
l1.append(4)
l1  # [1,2,3,4]
l2  # [1,2,3,4]
# 1. l1和l2同时指向了对象[1,2,3]
# 2. 由于**列表是可变的，所以l1.append(4)不会创建新的列表**，而是在原列表的末尾插入了4。
# 3. 由于l1 l2同时指向这个列表，所以列表的变化同时反映在l1和l2上，那么l1和l2的值同时变成了[1,2,3,4]

# summary
# 1. 变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量；而一个对象，可以被多个变量所指向。
# 2. 可变对象（列表，字典，集合等）的改变，会影响所有指向改对象的变量。
# 3. 不可变对象（字符串、整型、元组等），所有指向该对象的变量的值总是一样的，也不会改变，通过+=更新不可变对象的值时，会返回一个新的对象。
# 4. 变量可以被删除，但对象无法被删除，会被垃圾回收。

def func3(l2):
    l2.append(4)
l1 = [1,2,3]
func3(l1)
l1
[1,2,3,4]

def func4(l2):
    l2 = l2 + [4]   # 表示创建了一个‘末尾加入4的新列表’
l1 = [1,2,3]
func4(l1)
l1
[1,2,3]

def func1(b):
    b = 2
a = 1
func1(a)
a
1