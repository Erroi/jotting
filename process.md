> 进程 vs 线程
  * 进程：就是一个程序的运行实例，启动程序的时候，操作系统会为改程序创建一块内存，用来存放代码、运行的数据和一个执行任务的主线程
  * 线程：依附于进程，而进程中使用多线程并行处理能提升运算效率

      1 进程中有任一线程执行出错，会导致整个进程崩溃
      2 线程之间共享数据
      3 当一个进程关闭后，操作系统会回收进程所占用的内存
      4 进程之间的内容相互隔离

> chrome浏览器包括的进程：
    1、一个浏览器Browser主进程：主要负责界面显示、用户交互、子进程管理、同时提供
    2、一个网络进程Network：页面的网页资源加载
    5、一个GPU进程：UI界面的绘制
    3、多个渲染进程：将HTML、CSS、JS转换为用户可以与之交互的网页，排版引擎Blik和JavaScript引擎k8s，每个标签一个渲染进程（除同源），运行在沙箱模式下。
    4、多个插件进程

> 互联网数据是通过数据包来传输的：
    1. IP负责吧数据包送到目的主机
    2. UDP负责吧数据包送达到具体应用
    3. TCP保证数据的完整传输（一个TCP连接的生命周期）：
       a、首先，建立连接阶段
          通过‘三次握手’来建立客户端和服务器之间的连接（指客户端与服务器总共要发送三个数据包以确认连接的建立）
       b、传输数据阶段
          接收端需要对每个数据包进行确认操作，（若没有收到接收端发的确认收到的信息，择任务数据包丢失，重发）
       c、最后断开连接阶段
          ‘四次挥手’

      
> 输入url后，浏览器会有哪些动作？

  1. 构建请求：浏览器构建请求行信息（GET /index.html HTTP1.1）,之后浏览器「准备」发起网络请求
  2. 查找缓存：在发起网络请求之前，浏览器会先在浏览器缓存里查询是否有要请求的文件，（浏览器缓存是：一种在本地保存资源副本，以供下次请求是直接使用的技术）如果有，则拦截请求
  3. 准备IP地址和端口： 浏览器使用HTTP协议作为应用层歇息，用来封装请求的文本信息；使用TCP/IP做传输层协议发到网络上，所以，浏览器需要通过TCP与服务器建立连接，「HTTP的内容是通过TCP的传输数据阶段实现的」
    a、step1. 浏览器会请求DNS返回域名对应的IP，（浏览器也提供了DNS数据缓存）
    b、默认端口80
  4. 等待TCP队列：chrome机制，同时一个域名最多可以创建6个tcp连接，其他进入排队等待
  5. 建立TCP连接
  6. 发送HTTP请求：请求行，请求头，请求体
  7. 服务器处理HTTP请求
  8. 返回请求：响应头（数据类型、cookie等）
  9. 断开连接：如果有 Connection: Keep-Alive，则仍保持连接专题

> 重定向

    satus: 301,重定向
    响应头里 Location： url,重新导向这个地址


> 浏览器，从输入URL到页面展示，中间发生了什么？

    1. 用户输入：（浏览器进程）地址栏会判断输入的关键字是搜索内容，还是请求的URL
                搜索内容，地址栏会使用浏览器默认的搜索引擎，合成新的带搜索关键字的URL。
                URL，地址栏会根据规则加上协议，合成完整的URL。
    2. 资源请求：（网络进程）吧URL请求发送至网络进程，网络进程接收到URL请求后，发起URL请求流程：
                a，查找本地缓存：有则直接返回资源；没有则进入请求流程。
                b、DNS解析：获取请求域名的服务器IP，如果是HTTPS，需要建立TLS连接。
                c、建立TCP连接，后浏览器将构建请求行、头信息和cookie等数据加到请求头中，向服务器发送。
                d、服务器接受后根据请求信息生成相应数据（响应行、头、体），网络进程开始解析响应内容。
                    1）、重定向 301，302；根据Location读取重定向地址，再发起此地址的http
                    2）、响应数据处理：浏览器根据Content-Type值决定显示内容（text/html、application/octet-stream）
    3.渲染进程： 为每个页面配置渲染进程（同源）
    4.提交文档： ‘文档’是指URL响应体数据
                    1）‘提交文档’的消息是由浏览器进程发出的，渲染进程接受到此消息后，回合网络进程建立传输数据的‘管道’
                    2） 等文档数据传输完成后，渲染进程会返回‘确认提交’的消息给浏览器进程。
                    3） 浏览器收到消息后，会更新浏览器界面的转态（安全状态、地址栏的URL、前进后退的历史状态）
                    4） 跟新web页面
    5.渲染阶段：渲染进程开始解析页面和子资源加载（一旦页面生成，渲染进程会发消息给浏览器进程，！！！才停止转圈）
                    1)「DOM」 构建DOM树：是一个html文件经由HTML解析器解析，最终输出树状结构的DOM
                    2）「Style」计算样式：让DOM节点有正确的样式，需要样式计算。
                        a、把CSS转换为浏览器能够理解的结构styleSheets
                        b、转换样式表中的属性值，使其标准化
                        c、计算出DOM树中每个节点的具体样式（CSS继承规则和层叠规则）
                    3）「Layout」布局阶段：计算出DOM树种可见元素的几何位置，称为布局：遍历所有可见节点，并加到布局树中，计算布局坐标
                    4）「Layer」分层：由于3D转换、页面滚动、z-indexing做z轴排序，需要生成专用的图层，并生成一颗对应的图层树LayerTree
                        a、拥有层叠上下文属性的元素会被提升为单独的一层
                        b、需要裁剪的地方会被创建为图层
                    5）「Pain」绘制：对每个图层进行绘制，渲染进程会将此任务转给「合成线程」
                    6）「tiles」分块：合成线程将图层划分为图块
                    7）「raster」光栅化：合成线程会按照视口附加的图块优先生成位图，使用GPU来加速生成，生成的位图保存在GPU中，（GPU进程中完成）
                    8）「display」显示：浏览器进程接受到DrawQuad命令，将页面内容绘制到内存中，显示在屏幕上

> 重排、重绘、合成

  ** 重排：更新了元素的集合属性（从步骤2「style」开始执行一遍Layout、Layer、Pain...）
  ** 重绘：更新元素的绘制属性（直接进入Pain阶段）
  ** 直接合成阶段：如translate，（直接进入步骤6「tiles、raster、display」，同时也没有占用主线程，所有效率最高）


> 变量提升
    变量和函数声明在代码里的位置是不会改变的，而是在编译阶段被javascript引擎放入内存中。（先编译后执行）

        showName()
        console.log(myname)
        var myname = 'jksj‘
        function showName() {
            console.log('showName)
        }

        模拟变量提升：
        var myname = undefined
        function showName() {
            console.log('showName)
        }
        showName()
        console.log(myName)
        myname = 'jksj'

    1. 在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为undefined，
    2. 在执行阶段，js引擎会从变量环境中去查找自定义的变量和函数

> 执行上下文
    当一段代码被执行时，js引擎会对其进行编译，并创建执行上下文
    1. 当js执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份
    2. 当调用一个函数的时候，函数体内的代码会被便衣，并创建函数执行上下文。

    运用栈来管理js的执行上下文，又称调用栈。
    1. 每调用一个函数，JavaScript引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后JavaScript引擎开始执行函数代码。
    2.如果在一个函数A中调用另外一个函数B，那么JavaScript引擎会为B函数创建执行上下文，并将B函数的执行上下文压入栈顶
    3.当函数执行完毕后，JavaScript引擎会将该函数的执行上下文弹出栈
    4.当分配的调用栈空间被占满时，会引发’堆栈溢出‘问题。

> 作用域
    函数执行上下文--> 变量环境（var声明的变量存放在变量环境中） + 词法环境（块级作用域let、count申明的变量在编译时被存放在词法环境中） + 外部引用outer + this

> 作用域链
    1. 查找一个变量时，顺序：
        当前执行上下文（词法环境 -> 变量环境）--> outer所指向的全局执行上下文 --> 父级作用域

> 闭包
    根据词法作用域规则，内部函数总是可以访问外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束，但内部函数引用外部函数变量依然保存在内存中，我们就把这些变量的集合称为闭包。
    通俗讲：父函数foo执行完后，其执行上下文从栈顶弹出，但因为返回的setName和getName方法中用到foo的内部变量，所以这个内部变量依然保存在内存中。

    闭包使用原则：如果该闭包会一直使用，那么他可以作为全局变量而存在，如果使用评率不高，又占内存的话就尽量使他成为一个局部变量。